<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Vim 百科（Vim Encyclopedia）</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet" />
  <style>
    :root {
      color-scheme: dark;
      --bg: #0f1115;
      --panel: #141925;
      --panel-2: #1b2233;
      --accent: #7c5cff;
      --accent-2: #3dd5f3;
      --text: #e6e9f2;
      --muted: #9aa3b2;
      --border: #2a3142;
      --success: #4ade80;
      --warning: #facc15;
      --danger: #f87171;
      --highlight: #2f3a57;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: "Inter", "Noto Sans TC", sans-serif;
    }

    body {
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .app {
      display: flex;
      flex-direction: column;
      gap: 16px;
      padding: 20px;
      max-width: 1400px;
      width: 100%;
      margin: 0 auto;
      flex: 1;
    }

    .toolbar {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 14px;
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      padding: 12px 16px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      border-radius: 999px;
      background: var(--panel-2);
      color: var(--muted);
      font-size: 12px;
      font-weight: 600;
      letter-spacing: 0.03em;
      text-transform: uppercase;
    }

    .chip strong {
      color: var(--text);
      font-size: 13px;
      text-transform: none;
      letter-spacing: normal;
    }

    .toolbar .grow {
      flex: 1;
    }

    .toolbar button,
    .toolbar select {
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text);
      border-radius: 10px;
      padding: 8px 12px;
      cursor: pointer;
      transition: all 0.2s ease;
      font-weight: 600;
    }

    .toolbar button:hover,
    .toolbar select:hover {
      border-color: var(--accent);
      color: var(--accent);
    }

    .layout {
      display: grid;
      grid-template-columns: minmax(0, 7fr) minmax(0, 3fr);
      gap: 16px;
      flex: 1;
    }

    .terminal {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 18px;
      display: flex;
      flex-direction: column;
      min-height: 600px;
      overflow: hidden;
      position: relative;
    }

    .terminal-header {
      padding: 12px 16px;
      border-bottom: 1px solid var(--border);
      background: linear-gradient(90deg, rgba(124, 92, 255, 0.15), transparent 70%);
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 13px;
      color: var(--muted);
    }

    .terminal-body {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 12px 0;
      overflow: hidden;
    }

    .editor {
      flex: 1;
      overflow: auto;
      padding: 0 16px;
    }

    .editor:focus {
      outline: none;
      box-shadow: inset 0 0 0 2px rgba(124, 92, 255, 0.4);
    }

    .line {
      display: flex;
      align-items: flex-start;
      font-size: 15px;
      line-height: 1.6;
      white-space: pre;
    }

    .line-number {
      width: 44px;
      text-align: right;
      color: var(--muted);
      padding-right: 12px;
      user-select: none;
    }

    .line-content {
      flex: 1;
      position: relative;
      white-space: pre;
    }

    .cursor {
      background: var(--accent);
      color: #0f1115;
      border-radius: 2px;
      padding: 0 1px;
      animation: blink 1.1s step-end infinite;
    }

    .cursor.block {
      padding: 0 2px;
    }

    .selection {
      background: rgba(124, 92, 255, 0.35);
    }

    .search-highlight {
      background: rgba(61, 213, 243, 0.35);
      border-bottom: 1px solid var(--accent-2);
    }

    .statusbar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 16px;
      border-top: 1px solid var(--border);
      background: var(--panel-2);
      color: var(--muted);
      font-size: 12px;
      gap: 16px;
    }

    .status-message {
      color: var(--success);
      font-weight: 600;
    }

    .command-line {
      border-top: 1px solid var(--border);
      background: #0f141f;
      padding: 8px 16px;
      font-family: "JetBrains Mono", "SFMono-Regular", monospace;
      font-size: 14px;
      color: var(--text);
      min-height: 34px;
    }

    .command-line.hidden {
      opacity: 0.4;
      color: var(--muted);
    }

    .encyclopedia {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 18px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .encyclopedia-header {
      padding: 16px;
      border-bottom: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .encyclopedia-header input {
      border-radius: 10px;
      border: 1px solid var(--border);
      padding: 10px 12px;
      background: var(--panel-2);
      color: var(--text);
    }

    .tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .tab {
      border: 1px solid transparent;
      padding: 6px 12px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 600;
      background: var(--panel-2);
      color: var(--muted);
      cursor: pointer;
    }

    .tab.active {
      background: var(--accent);
      color: #0f1115;
      border-color: rgba(255, 255, 255, 0.2);
    }

    .encyclopedia-list {
      padding: 12px 16px 16px;
      overflow: auto;
      display: flex;
      flex-direction: column;
      gap: 12px;
      flex: 1;
    }

    .entry {
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 12px;
      background: var(--panel-2);
      display: grid;
      gap: 8px;
    }

    .entry-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    .entry-keys {
      font-family: "JetBrains Mono", "SFMono-Regular", monospace;
      font-weight: 700;
      color: var(--accent);
      font-size: 13px;
    }

    .entry-title {
      font-weight: 700;
      font-size: 14px;
    }

    .entry-desc {
      color: var(--muted);
      font-size: 13px;
      line-height: 1.5;
    }

    .entry-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .entry-actions button {
      border: 1px solid var(--border);
      background: transparent;
      color: var(--text);
      padding: 6px 10px;
      border-radius: 8px;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .entry-actions button:hover {
      border-color: var(--accent);
      color: var(--accent);
    }

    .hint {
      font-size: 12px;
      color: var(--muted);
      margin-left: auto;
    }

    .key-buffer {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
      font-size: 12px;
      color: var(--muted);
    }

    .key-chip {
      padding: 2px 8px;
      background: #222a3d;
      border-radius: 999px;
      font-family: "JetBrains Mono", "SFMono-Regular", monospace;
      font-size: 12px;
    }

    .help-panel {
      position: absolute;
      right: 16px;
      top: 16px;
      background: rgba(20, 25, 37, 0.95);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      width: min(320px, 90%);
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.35);
      display: none;
    }

    .help-panel.active {
      display: block;
    }

    .help-panel h4 {
      margin-bottom: 8px;
      font-size: 14px;
    }

    .help-panel p {
      font-size: 12px;
      color: var(--muted);
      line-height: 1.5;
    }

    @keyframes blink {
      50% {
        opacity: 0.1;
      }
    }

    @media (max-width: 1024px) {
      .layout {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <main class="app">
    <section class="toolbar">
      <div class="chip">模式 <strong id="mode-indicator">NORMAL</strong></div>
      <div class="chip">檔名 <strong id="filename">demo.txt</strong></div>
      <div class="chip grow">
        <div class="key-buffer" id="key-buffer"></div>
      </div>
      <select id="sample-select" aria-label="載入範例">
        <option value="">載入範例</option>
      </select>
      <button id="reset-btn">Reset</button>
    </section>

    <section class="layout">
      <div class="terminal">
        <div class="terminal-header">
          <span>Vim 模擬器 / 教學視窗</span>
          <span class="hint">點擊左側以聚焦鍵盤輸入</span>
        </div>
        <div class="terminal-body">
          <div id="editor" class="editor" tabindex="0" aria-label="Vim 編輯區"></div>
          <div class="statusbar">
            <div>
              <span id="status-mode">-- NORMAL --</span>
              <span id="status-message" class="status-message"></span>
            </div>
            <div>
              <span id="status-position">Ln 1, Col 1</span>
              <span id="status-selection"></span>
              <span id="status-search"></span>
            </div>
          </div>
          <div id="command-line" class="command-line hidden">:</div>
        </div>
        <div class="help-panel" id="help-panel">
          <h4>Vim 百科說明</h4>
          <p>這裡是教學用的 Vim 模擬器，支援常見模式、游標移動、刪除、搜尋與命令列。</p>
          <p>可從右側百科點選「示範」或「插入按鍵」觀看效果。</p>
        </div>
      </div>

      <aside class="encyclopedia">
        <div class="encyclopedia-header">
          <input id="search-input" type="search" placeholder="搜尋指令、關鍵字或分類" />
          <div id="tabs" class="tabs"></div>
        </div>
        <div id="encyclopedia-list" class="encyclopedia-list"></div>
      </aside>
    </section>
  </main>

  <script>
    const state = {
      lines: [""],
      cursor: { row: 0, col: 0 },
      mode: "NORMAL",
      selection: null,
      register: "",
      history: [],
      redo: [],
      search: { term: "", matches: [], index: -1 },
      settings: { number: true },
      keyBuffer: [],
      pending: "",
      commandLine: { active: false, value: "", type: ":" },
      statusMessage: "",
      filename: "demo.txt",
      helpVisible: false,
      demoPlaying: false
    };

    const editor = document.getElementById("editor");
    const modeIndicator = document.getElementById("mode-indicator");
    const keyBufferEl = document.getElementById("key-buffer");
    const statusMode = document.getElementById("status-mode");
    const statusMessage = document.getElementById("status-message");
    const statusPosition = document.getElementById("status-position");
    const statusSelection = document.getElementById("status-selection");
    const statusSearch = document.getElementById("status-search");
    const commandLine = document.getElementById("command-line");
    const sampleSelect = document.getElementById("sample-select");
    const resetBtn = document.getElementById("reset-btn");
    const helpPanel = document.getElementById("help-panel");

    const categories = ["全部", "移動", "編輯", "刪除/變更", "搜尋", "視覺模式", "命令列", "技巧"];

    const encyclopediaItems = [
      {
        id: "move-hjkl",
        keys: "h j k l",
        mode: "NORMAL",
        category: "移動",
        title: "基本方向移動",
        desc: "左右上下移動游標。",
        example: "在文字中逐字移動",
        demoSequence: ["l", "l", "j", "h", "k"]
      },
      {
        id: "move-word",
        keys: "w / b",
        mode: "NORMAL",
        category: "移動",
        title: "單字移動",
        desc: "w 前進到下一個單字、b 回到上一個單字。",
        example: "快速跳轉單字起點",
        demoSequence: ["w", "w", "b"]
      },
      {
        id: "move-line",
        keys: "0 / $",
        mode: "NORMAL",
        category: "移動",
        title: "行首行尾",
        desc: "0 到行首，$ 到行尾。",
        example: "快速移動到行尾",
        demoSequence: ["$", "0"]
      },
      {
        id: "move-file",
        keys: "gg / G",
        mode: "NORMAL",
        category: "移動",
        title: "文件首尾",
        desc: "gg 到第一行，G 到最後一行。",
        example: "快速定位文件",
        demoSequence: ["G", "g", "g"]
      },
      {
        id: "insert",
        keys: "i",
        mode: "NORMAL",
        category: "編輯",
        title: "進入插入模式",
        desc: "游標前開始輸入文字。",
        example: "i Hello<Esc>",
        demoSequence: ["i", "H", "e", "l", "l", "o", "<Esc>"]
      },
      {
        id: "delete-char",
        keys: "x",
        mode: "NORMAL",
        category: "刪除/變更",
        title: "刪除游標字元",
        desc: "刪除當前游標位置字元。",
        example: "x",
        demoSequence: ["x"]
      },
      {
        id: "delete-line",
        keys: "dd",
        mode: "NORMAL",
        category: "刪除/變更",
        title: "刪除整行",
        desc: "刪除目前游標所在行。",
        example: "dd",
        demoSequence: ["d", "d"]
      },
      {
        id: "change-word",
        keys: "cw",
        mode: "NORMAL",
        category: "刪除/變更",
        title: "變更單字",
        desc: "刪除游標到字尾並進入 INSERT。",
        example: "cw新的字<Esc>",
        demoSequence: ["c", "w", "新", "的", "字", "<Esc>"]
      },
      {
        id: "replace",
        keys: "r{char}",
        mode: "NORMAL",
        category: "刪除/變更",
        title: "取代單一字元",
        desc: "使用下一個輸入字元取代游標字元。",
        example: "ra",
        demoSequence: ["r", "A"]
      },
      {
        id: "undo",
        keys: "u / Ctrl+r",
        mode: "NORMAL",
        category: "編輯",
        title: "復原與重做",
        desc: "u 復原、Ctrl+r 重做。",
        example: "u, Ctrl+r",
        demoSequence: ["u", "<C-r>"]
      },
      {
        id: "visual",
        keys: "v",
        mode: "NORMAL",
        category: "視覺模式",
        title: "視覺選取",
        desc: "進入視覺模式，h/j/k/l 擴縮選取。",
        example: "v ll y",
        demoSequence: ["v", "l", "l", "y"]
      },
      {
        id: "visual-delete",
        keys: "d",
        mode: "VISUAL",
        category: "視覺模式",
        title: "刪除選取",
        desc: "刪除選取範圍文字。",
        example: "v ll d",
        demoSequence: ["v", "l", "l", "d"]
      },
      {
        id: "search",
        keys: "/",
        mode: "NORMAL",
        category: "搜尋",
        title: "搜尋",
        desc: "輸入 / 關鍵字，Enter 執行搜尋。",
        example: "/vim",
        demoSequence: ["/", "v", "i", "m", "<Enter>"]
      },
      {
        id: "search-next",
        keys: "n / N",
        mode: "NORMAL",
        category: "搜尋",
        title: "搜尋下一筆",
        desc: "n 跳下一筆，N 回上一筆。",
        example: "n",
        demoSequence: ["n", "N"]
      },
      {
        id: "command-line",
        keys: ":",
        mode: "NORMAL",
        category: "命令列",
        title: "命令列",
        desc: "輸入 :w, :q, :set number 等命令。",
        example: ":set nonumber",
        demoSequence: [":", "s", "e", "t", " ", "n", "o", "n", "u", "m", "b", "e", "r", "<Enter>"]
      },
      {
        id: "tips",
        keys: "Esc",
        mode: "ANY",
        category: "技巧",
        title: "返回 NORMAL",
        desc: "離開 INSERT/VISUAL/COMMAND-LINE 回 NORMAL。",
        example: "Esc",
        demoSequence: ["<Esc>"]
      }
    ];

    const samples = [
      {
        id: "article",
        name: "一般文章",
        filename: "article.txt",
        content: "Vim 是一套以鍵盤操作為核心的文字編輯器。\n它強調模式切換與效率，讓輸入與指令分離。\n在教學中，我們會從 hjkl 開始練習，再學習刪除、搜尋與命令列。\n熟悉後，你可以用更少的按鍵完成更多工作。"
      },
      {
        id: "code",
        name: "程式碼",
        filename: "demo.js",
        content: "function greet(name) {\n  const message = `Hello, ${name}!`;\n  console.log(message);\n  return message;\n}\n\nexport default greet;"
      },
      {
        id: "log",
        name: "系統 Log",
        filename: "system.log",
        content: "[10:32:01] INFO  Server started on :3000\n[10:32:08] WARN  Deprecated API called\n[10:32:15] INFO  User login: admin\n[10:32:22] ERROR Database timeout\n[10:32:30] INFO  Retrying connection..."
      }
    ];

    const tabsEl = document.getElementById("tabs");
    const searchInput = document.getElementById("search-input");
    const listEl = document.getElementById("encyclopedia-list");

    let activeCategory = "全部";
    let renderQueued = false;

    const escapeHtml = (value) =>
      value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");

    const scheduleRender = () => {
      if (renderQueued) return;
      renderQueued = true;
      requestAnimationFrame(() => {
        renderQueued = false;
        render();
      });
    };

    const pushKeyBuffer = (key) => {
      state.keyBuffer.push(key);
      if (state.keyBuffer.length > 10) state.keyBuffer.shift();
      scheduleRender();
    };

    const setStatusMessage = (message, tone = "success") => {
      state.statusMessage = message;
      statusMessage.style.color =
        tone === "warning" ? "var(--warning)" : tone === "danger" ? "var(--danger)" : "var(--success)";
      scheduleRender();
    };

    const clearStatusMessage = () => {
      state.statusMessage = "";
      scheduleRender();
    };

    const normalizePosition = () => {
      state.cursor.row = Math.max(0, Math.min(state.cursor.row, state.lines.length - 1));
      const lineLength = state.lines[state.cursor.row].length;
      state.cursor.col = Math.max(0, Math.min(state.cursor.col, lineLength));
    };

    const setMode = (mode) => {
      state.mode = mode;
      if (mode !== "VISUAL") {
        state.selection = null;
      }
      if (mode !== "COMMAND-LINE") {
        state.commandLine.active = false;
        state.commandLine.value = "";
      }
      scheduleRender();
    };

    const consumeKeyBuffer = () => {
      state.keyBuffer = [];
      scheduleRender();
    };

    const recordHistory = () => {
      state.history.push({
        lines: state.lines.map((line) => line),
        cursor: { ...state.cursor }
      });
      if (state.history.length > 100) state.history.shift();
      state.redo = [];
    };

    const undo = () => {
      if (!state.history.length) {
        setStatusMessage("沒有可復原的動作", "warning");
        return;
      }
      const snapshot = state.history.pop();
      state.redo.push({ lines: state.lines.map((line) => line), cursor: { ...state.cursor } });
      state.lines = snapshot.lines.map((line) => line);
      state.cursor = { ...snapshot.cursor };
      normalizePosition();
      setStatusMessage("已復原", "success");
    };

    const redo = () => {
      if (!state.redo.length) {
        setStatusMessage("沒有可重做的動作", "warning");
        return;
      }
      const snapshot = state.redo.pop();
      state.history.push({ lines: state.lines.map((line) => line), cursor: { ...state.cursor } });
      state.lines = snapshot.lines.map((line) => line);
      state.cursor = { ...snapshot.cursor };
      normalizePosition();
      setStatusMessage("已重做", "success");
    };

    const moveCursor = (rowDelta, colDelta) => {
      state.cursor.row += rowDelta;
      state.cursor.col += colDelta;
      normalizePosition();
      scheduleRender();
    };

    const moveToLineStart = () => {
      state.cursor.col = 0;
      scheduleRender();
    };

    const moveToLineEnd = () => {
      state.cursor.col = state.lines[state.cursor.row].length;
      scheduleRender();
    };

    const wordChar = (char) => /[A-Za-z0-9_]/.test(char || "");

    const moveWordForward = () => {
      const line = state.lines[state.cursor.row];
      let idx = state.cursor.col + 1;
      while (idx < line.length && !wordChar(line[idx])) idx++;
      while (idx < line.length && wordChar(line[idx])) {
        state.cursor.col = idx;
        idx++;
        return scheduleRender();
      }
      if (state.cursor.row < state.lines.length - 1) {
        state.cursor.row += 1;
        state.cursor.col = 0;
      }
      scheduleRender();
    };

    const moveWordBackward = () => {
      const line = state.lines[state.cursor.row];
      let idx = state.cursor.col - 1;
      while (idx >= 0 && !wordChar(line[idx])) idx--;
      while (idx >= 0 && wordChar(line[idx])) {
        state.cursor.col = idx;
        idx--;
      }
      if (idx < 0 && state.cursor.col === 0 && state.cursor.row > 0) {
        state.cursor.row -= 1;
        state.cursor.col = state.lines[state.cursor.row].length;
      }
      scheduleRender();
    };

    const moveToFileStart = () => {
      state.cursor.row = 0;
      state.cursor.col = 0;
      scheduleRender();
    };

    const moveToFileEnd = () => {
      state.cursor.row = state.lines.length - 1;
      state.cursor.col = state.lines[state.cursor.row].length;
      scheduleRender();
    };

    const insertText = (text) => {
      recordHistory();
      const line = state.lines[state.cursor.row];
      const before = line.slice(0, state.cursor.col);
      const after = line.slice(state.cursor.col);
      state.lines[state.cursor.row] = `${before}${text}${after}`;
      state.cursor.col += text.length;
      setStatusMessage("已插入文字", "success");
      scheduleRender();
    };

    const insertNewLine = () => {
      recordHistory();
      const line = state.lines[state.cursor.row];
      const before = line.slice(0, state.cursor.col);
      const after = line.slice(state.cursor.col);
      state.lines[state.cursor.row] = before;
      state.lines.splice(state.cursor.row + 1, 0, after);
      state.cursor.row += 1;
      state.cursor.col = 0;
      scheduleRender();
    };

    const backspace = () => {
      if (state.cursor.col === 0 && state.cursor.row === 0) return;
      recordHistory();
      if (state.cursor.col > 0) {
        const line = state.lines[state.cursor.row];
        state.lines[state.cursor.row] = line.slice(0, state.cursor.col - 1) + line.slice(state.cursor.col);
        state.cursor.col -= 1;
      } else {
        const current = state.lines[state.cursor.row];
        const prev = state.lines[state.cursor.row - 1];
        state.cursor.col = prev.length;
        state.lines[state.cursor.row - 1] = prev + current;
        state.lines.splice(state.cursor.row, 1);
        state.cursor.row -= 1;
      }
      scheduleRender();
    };

    const deleteChar = () => {
      const line = state.lines[state.cursor.row];
      if (state.cursor.col >= line.length && state.cursor.row === state.lines.length - 1) return;
      recordHistory();
      if (state.cursor.col < line.length) {
        state.lines[state.cursor.row] = line.slice(0, state.cursor.col) + line.slice(state.cursor.col + 1);
      } else {
        const next = state.lines[state.cursor.row + 1] || "";
        state.lines[state.cursor.row] = line + next;
        state.lines.splice(state.cursor.row + 1, 1);
      }
      setStatusMessage("已刪除字元", "success");
      scheduleRender();
    };

    const deleteLine = () => {
      recordHistory();
      state.register = state.lines[state.cursor.row] + "\n";
      state.lines.splice(state.cursor.row, 1);
      if (!state.lines.length) state.lines.push("");
      state.cursor.row = Math.min(state.cursor.row, state.lines.length - 1);
      state.cursor.col = Math.min(state.cursor.col, state.lines[state.cursor.row].length);
      setStatusMessage("已刪除一行", "success");
      scheduleRender();
    };

    const deleteToNextWord = () => {
      recordHistory();
      const line = state.lines[state.cursor.row];
      let idx = state.cursor.col;
      if (idx < line.length && wordChar(line[idx])) {
        while (idx < line.length && wordChar(line[idx])) idx++;
      }
      while (idx < line.length && !wordChar(line[idx])) idx++;
      state.register = line.slice(state.cursor.col, idx);
      state.lines[state.cursor.row] = line.slice(0, state.cursor.col) + line.slice(idx);
      setStatusMessage("已刪除單字", "success");
      scheduleRender();
    };

    const deleteToPrevWord = () => {
      recordHistory();
      const line = state.lines[state.cursor.row];
      let idx = state.cursor.col - 1;
      while (idx >= 0 && !wordChar(line[idx])) idx--;
      while (idx >= 0 && wordChar(line[idx])) idx--;
      const start = Math.max(0, idx + 1);
      state.register = line.slice(start, state.cursor.col);
      state.lines[state.cursor.row] = line.slice(0, start) + line.slice(state.cursor.col);
      state.cursor.col = start;
      setStatusMessage("已刪除上一個單字", "success");
      scheduleRender();
    };

    const changeWord = () => {
      deleteToNextWord();
      setMode("INSERT");
      setStatusMessage("已變更單字，進入 INSERT", "success");
    };

    const replaceChar = (char) => {
      const line = state.lines[state.cursor.row];
      if (state.cursor.col >= line.length) return;
      recordHistory();
      state.lines[state.cursor.row] =
        line.slice(0, state.cursor.col) + char + line.slice(state.cursor.col + 1);
      setStatusMessage("已取代字元", "success");
      scheduleRender();
    };

    const setSelectionAnchor = () => {
      state.selection = {
        anchor: { ...state.cursor },
        active: { ...state.cursor }
      };
    };

    const updateSelection = () => {
      if (!state.selection) return;
      state.selection.active = { ...state.cursor };
      scheduleRender();
    };

    const getSelectionRange = () => {
      if (!state.selection) return null;
      const { anchor, active } = state.selection;
      const start = anchor.row < active.row || (anchor.row === active.row && anchor.col <= active.col) ? anchor : active;
      const end = start === anchor ? active : anchor;
      return { start, end };
    };

    const selectionLength = () => {
      const range = getSelectionRange();
      if (!range) return 0;
      if (range.start.row === range.end.row) {
        return Math.abs(range.end.col - range.start.col);
      }
      let length = state.lines[range.start.row].length - range.start.col;
      for (let row = range.start.row + 1; row < range.end.row; row++) {
        length += state.lines[row].length;
      }
      length += range.end.col;
      return length;
    };

    const yankSelection = () => {
      const range = getSelectionRange();
      if (!range) return;
      const segments = [];
      if (range.start.row === range.end.row) {
        segments.push(state.lines[range.start.row].slice(range.start.col, range.end.col));
      } else {
        segments.push(state.lines[range.start.row].slice(range.start.col));
        for (let row = range.start.row + 1; row < range.end.row; row++) {
          segments.push(state.lines[row]);
        }
        segments.push(state.lines[range.end.row].slice(0, range.end.col));
      }
      state.register = segments.join("\n");
      setStatusMessage("已複製選取內容", "success");
    };

    const deleteSelection = () => {
      const range = getSelectionRange();
      if (!range) return;
      recordHistory();
      if (range.start.row === range.end.row) {
        const line = state.lines[range.start.row];
        state.lines[range.start.row] = line.slice(0, range.start.col) + line.slice(range.end.col);
        state.cursor = { ...range.start };
      } else {
        const first = state.lines[range.start.row].slice(0, range.start.col);
        const last = state.lines[range.end.row].slice(range.end.col);
        state.lines.splice(range.start.row, range.end.row - range.start.row + 1, first + last);
        state.cursor = { ...range.start };
      }
      setMode("NORMAL");
      setStatusMessage("已刪除選取", "success");
    };

    const pasteRegister = () => {
      if (!state.register) return;
      recordHistory();
      const text = state.register;
      const lines = text.split("\n");
      const currentLine = state.lines[state.cursor.row];
      const before = currentLine.slice(0, state.cursor.col);
      const after = currentLine.slice(state.cursor.col);
      if (lines.length === 1) {
        state.lines[state.cursor.row] = before + text + after;
        state.cursor.col += text.length;
      } else {
        const first = before + lines[0];
        const last = lines[lines.length - 1] + after;
        const middle = lines.slice(1, -1);
        const insertLines = [first, ...middle, last];
        state.lines.splice(state.cursor.row, 1, ...insertLines);
        state.cursor.row += lines.length - 1;
        state.cursor.col = lines[lines.length - 1].length;
      }
      setMode("NORMAL");
      setStatusMessage("已貼上", "success");
      scheduleRender();
    };

    const startCommandLine = (type) => {
      state.commandLine.active = true;
      state.commandLine.value = "";
      state.commandLine.type = type;
      setMode("COMMAND-LINE");
    };

    const finishCommandLine = () => {
      const command = state.commandLine.value.trim();
      if (state.commandLine.type === "/") {
        applySearch(command);
      } else {
        runCommand(command);
      }
      setMode("NORMAL");
    };

    const applySearch = (term) => {
      state.search.term = term;
      state.search.matches = [];
      state.search.index = -1;
      if (!term) {
        setStatusMessage("搜尋已清除", "warning");
        scheduleRender();
        return;
      }
      state.lines.forEach((line, row) => {
        let start = 0;
        while (start < line.length) {
          const idx = line.indexOf(term, start);
          if (idx === -1) break;
          state.search.matches.push({ row, start: idx, end: idx + term.length });
          start = idx + term.length;
        }
      });
      if (state.search.matches.length) {
        state.search.index = 0;
        const match = state.search.matches[0];
        state.cursor.row = match.row;
        state.cursor.col = match.start;
        setStatusMessage(`已搜尋到 ${state.search.matches.length} 筆`, "success");
      } else {
        setStatusMessage("沒有找到符合項目", "warning");
      }
      scheduleRender();
    };

    const jumpSearch = (direction) => {
      if (!state.search.matches.length) return;
      state.search.index =
        (state.search.index + direction + state.search.matches.length) % state.search.matches.length;
      const match = state.search.matches[state.search.index];
      state.cursor.row = match.row;
      state.cursor.col = match.start;
      scheduleRender();
    };

    const runCommand = (command) => {
      if (!command) return;
      if (command === "w") {
        setStatusMessage("已儲存（模擬）", "success");
      } else if (command === "q") {
        resetEditor();
        setStatusMessage("已退出（模擬）", "warning");
      } else if (command === "wq") {
        resetEditor();
        setStatusMessage("已儲存並退出（模擬）", "success");
      } else if (command === "set number") {
        state.settings.number = true;
        setStatusMessage("已啟用行號", "success");
      } else if (command === "set nonumber") {
        state.settings.number = false;
        setStatusMessage("已關閉行號", "success");
      } else if (command === "help") {
        state.helpVisible = true;
        setStatusMessage("開啟說明面板", "success");
      } else {
        setStatusMessage(`未知命令: ${command}`, "warning");
      }
      scheduleRender();
    };

    const resetEditor = () => {
      state.lines = [""];
      state.cursor = { row: 0, col: 0 };
      state.mode = "NORMAL";
      state.selection = null;
      state.register = "";
      state.history = [];
      state.redo = [];
      state.search = { term: "", matches: [], index: -1 };
      state.pending = "";
      state.commandLine = { active: false, value: "", type: ":" };
      state.statusMessage = "";
      scheduleRender();
    };

    const handleNormalKey = (key, event) => {
      if (state.pending === "d") {
        if (key === "d") {
          deleteLine();
        } else if (key === "w") {
          deleteToNextWord();
        } else if (key === "b") {
          deleteToPrevWord();
        }
        state.pending = "";
        consumeKeyBuffer();
        return;
      }
      if (state.pending === "c") {
        if (key === "w") {
          changeWord();
        }
        state.pending = "";
        consumeKeyBuffer();
        return;
      }
      if (state.pending === "g") {
        if (key === "g") {
          moveToFileStart();
          consumeKeyBuffer();
        }
        state.pending = "";
        return;
      }
      if (state.pending === "r") {
        if (key.length === 1) {
          replaceChar(key);
        }
        state.pending = "";
        consumeKeyBuffer();
        return;
      }

      switch (key) {
        case "h":
          moveCursor(0, -1);
          consumeKeyBuffer();
          break;
        case "j":
          moveCursor(1, 0);
          consumeKeyBuffer();
          break;
        case "k":
          moveCursor(-1, 0);
          consumeKeyBuffer();
          break;
        case "l":
          moveCursor(0, 1);
          consumeKeyBuffer();
          break;
        case "0":
          moveToLineStart();
          consumeKeyBuffer();
          break;
        case "$":
          moveToLineEnd();
          consumeKeyBuffer();
          break;
        case "w":
          moveWordForward();
          consumeKeyBuffer();
          break;
        case "b":
          moveWordBackward();
          consumeKeyBuffer();
          break;
        case "g":
          state.pending = "g";
          break;
        case "G":
          moveToFileEnd();
          consumeKeyBuffer();
          break;
        case "i":
          setMode("INSERT");
          consumeKeyBuffer();
          break;
        case "v":
          setMode("VISUAL");
          setSelectionAnchor();
          consumeKeyBuffer();
          break;
        case "x":
          deleteChar();
          consumeKeyBuffer();
          break;
        case "d":
          state.pending = "d";
          break;
        case "c":
          state.pending = "c";
          break;
        case "r":
          state.pending = "r";
          break;
        case "u":
          undo();
          consumeKeyBuffer();
          break;
        case "n":
          jumpSearch(1);
          consumeKeyBuffer();
          break;
        case "N":
          jumpSearch(-1);
          consumeKeyBuffer();
          break;
        case ":":
          startCommandLine(":");
          consumeKeyBuffer();
          break;
        case "/":
          startCommandLine("/");
          consumeKeyBuffer();
          break;
        default:
          break;
      }
    };

    const handleVisualKey = (key) => {
      switch (key) {
        case "h":
          moveCursor(0, -1);
          updateSelection();
          break;
        case "j":
          moveCursor(1, 0);
          updateSelection();
          break;
        case "k":
          moveCursor(-1, 0);
          updateSelection();
          break;
        case "l":
          moveCursor(0, 1);
          updateSelection();
          break;
        case "y":
          yankSelection();
          setMode("NORMAL");
          consumeKeyBuffer();
          break;
        case "d":
          deleteSelection();
          consumeKeyBuffer();
          break;
        case "p":
          deleteSelection();
          pasteRegister();
          consumeKeyBuffer();
          break;
        default:
          break;
      }
    };

    const handleInsertKey = (event) => {
      if (event.key === "Backspace") {
        backspace();
        return;
      }
      if (event.key === "Enter") {
        insertNewLine();
        return;
      }
      if (event.key.length === 1 && !event.ctrlKey && !event.metaKey) {
        insertText(event.key);
      }
    };

    const handleCommandLineKey = (event) => {
      if (event.key === "Enter") {
        finishCommandLine();
        consumeKeyBuffer();
        return;
      }
      if (event.key === "Backspace") {
        state.commandLine.value = state.commandLine.value.slice(0, -1);
        scheduleRender();
        return;
      }
      if (event.key.length === 1 && !event.ctrlKey && !event.metaKey) {
        state.commandLine.value += event.key;
        scheduleRender();
      }
    };

    const formatKeyToken = (event) => {
      if (event.key === "Escape") return "<Esc>";
      if (event.key === "Enter") return "<Enter>";
      if (event.key === "Backspace") return "<BS>";
      if (event.ctrlKey && event.key.toLowerCase() === "r") return "<C-r>";
      if (event.key === " ") return "<Space>";
      return event.key.length === 1 ? event.key : event.key;
    };

    const handleKeydown = (event) => {
      if (state.demoPlaying) return;
      if (event.key === "Tab") return;
      if (event.key === "Escape") {
        event.preventDefault();
        pushKeyBuffer("<Esc>");
        state.helpVisible = false;
        setMode("NORMAL");
        clearStatusMessage();
        return;
      }
      if (event.ctrlKey && event.key.toLowerCase() === "r") {
        event.preventDefault();
        pushKeyBuffer("<C-r>");
        redo();
        return;
      }
      if (event.ctrlKey || event.metaKey) return;

      const token = formatKeyToken(event);
      pushKeyBuffer(token);

      if (state.mode === "COMMAND-LINE") {
        event.preventDefault();
        handleCommandLineKey(event);
        return;
      }
      if (state.mode === "INSERT") {
        event.preventDefault();
        handleInsertKey(event);
        return;
      }
      if (state.mode === "VISUAL") {
        event.preventDefault();
        handleVisualKey(event.key);
        return;
      }
      if (state.mode === "NORMAL") {
        event.preventDefault();
        handleNormalKey(event.key, event);
      }
    };

    const renderKeyBuffer = () => {
      keyBufferEl.innerHTML = "";
      if (!state.keyBuffer.length) {
        keyBufferEl.innerHTML = "<span class=\"hint\">等待按鍵輸入…</span>";
        return;
      }
      state.keyBuffer.forEach((key) => {
        const chip = document.createElement("span");
        chip.className = "key-chip";
        chip.textContent = key;
        keyBufferEl.appendChild(chip);
      });
    };

    const renderEditor = () => {
      editor.innerHTML = "";
      const range = getSelectionRange();
      const selectionActive = state.mode === "VISUAL" && range;
      const searchMatches = state.search.matches;

      state.lines.forEach((lineText, row) => {
        const lineEl = document.createElement("div");
        lineEl.className = "line";
        const lineNumber = document.createElement("div");
        lineNumber.className = "line-number";
        lineNumber.textContent = state.settings.number ? String(row + 1).padStart(2, "0") : "";
        const content = document.createElement("div");
        content.className = "line-content";

        const segments = [];
        let cursorInserted = false;

        const buildSpan = (text, className) => {
          if (text === "") return;
          const span = document.createElement("span");
          span.className = className || "";
          span.textContent = text;
          segments.push(span);
        };

        const lineLength = lineText.length;
        const selectionStart = selectionActive && range.start.row === row ? range.start.col : null;
        const selectionEnd = selectionActive && range.end.row === row ? range.end.col : null;

        const searchSpans = searchMatches.filter((match) => match.row === row);

        const buildComposite = () => {
          let index = 0;
          const highlights = [];
          if (selectionActive) {
            const start = range.start.row < row ? 0 : range.start.col;
            const end = range.end.row > row ? lineLength : range.end.col;
            highlights.push({ start, end, type: "selection" });
          }
          searchSpans.forEach((match) => {
            highlights.push({ start: match.start, end: match.end, type: "search" });
          });
          highlights.sort((a, b) => a.start - b.start);

          while (index <= lineLength) {
            const isCursor = row === state.cursor.row && index === state.cursor.col;
            const nextHighlight = highlights.find((item) => item.start === index);
            if (isCursor && !cursorInserted) {
              const cursorSpan = document.createElement("span");
              cursorSpan.className = "cursor block";
              cursorSpan.textContent = lineText[index] || " ";
              segments.push(cursorSpan);
              cursorInserted = true;
              index = Math.max(index + 1, index);
              continue;
            }
            if (nextHighlight) {
              if (nextHighlight.start > index) {
                buildSpan(lineText.slice(index, nextHighlight.start));
              }
              const className = nextHighlight.type === "selection" ? "selection" : "search-highlight";
              buildSpan(lineText.slice(nextHighlight.start, nextHighlight.end), className);
              index = nextHighlight.end;
              continue;
            }
            if (index < lineLength) {
              buildSpan(lineText.slice(index, lineLength));
              index = lineLength;
              continue;
            }
            if (!cursorInserted && row === state.cursor.row && index === lineLength) {
              const cursorSpan = document.createElement("span");
              cursorSpan.className = "cursor block";
              cursorSpan.textContent = " ";
              segments.push(cursorSpan);
              cursorInserted = true;
            }
            break;
          }
        };

        buildComposite();
        segments.forEach((seg) => content.appendChild(seg));

        lineEl.appendChild(lineNumber);
        lineEl.appendChild(content);
        editor.appendChild(lineEl);
      });
    };

    const renderStatus = () => {
      modeIndicator.textContent = state.mode;
      statusMode.textContent = `-- ${state.mode} --`;
      statusMessage.textContent = state.statusMessage ? ` ${state.statusMessage}` : "";
      statusPosition.textContent = `Ln ${state.cursor.row + 1}, Col ${state.cursor.col + 1}`;
      document.getElementById("filename").textContent = state.filename;

      const selectionLen = selectionLength();
      statusSelection.textContent = selectionLen ? ` | 選取 ${selectionLen} 字` : "";

      if (state.search.term) {
        const index = state.search.index >= 0 ? state.search.index + 1 : 0;
        statusSearch.textContent = ` | /${state.search.term} (${index}/${state.search.matches.length})`;
      } else {
        statusSearch.textContent = "";
      }

      if (state.mode === "COMMAND-LINE") {
        commandLine.classList.remove("hidden");
        commandLine.textContent = `${state.commandLine.type}${state.commandLine.value}`;
      } else {
        commandLine.classList.add("hidden");
        commandLine.textContent = ":";
      }

      helpPanel.classList.toggle("active", state.helpVisible);
    };

    const render = () => {
      renderKeyBuffer();
      renderEditor();
      renderStatus();
    };

    const renderTabs = () => {
      tabsEl.innerHTML = "";
      categories.forEach((category) => {
        const button = document.createElement("button");
        button.className = `tab${category === activeCategory ? " active" : ""}`;
        button.textContent = category;
        button.addEventListener("click", () => {
          activeCategory = category;
          renderTabs();
          renderEncyclopedia();
        });
        tabsEl.appendChild(button);
      });
    };

    const renderEncyclopedia = () => {
      const keyword = searchInput.value.trim().toLowerCase();
      const filtered = encyclopediaItems.filter((item) => {
        const matchesCategory = activeCategory === "全部" || item.category === activeCategory;
        if (!matchesCategory) return false;
        if (!keyword) return true;
        const haystack = [item.keys, item.title, item.desc, item.category].join(" ").toLowerCase();
        return haystack.includes(keyword);
      });

      listEl.innerHTML = "";
      filtered.forEach((item) => {
        const card = document.createElement("div");
        card.className = "entry";
        card.innerHTML = `
          <div class="entry-header">
            <div>
              <div class="entry-keys">${escapeHtml(item.keys)}</div>
              <div class="entry-title">${escapeHtml(item.title)}</div>
            </div>
            <span class="hint">${escapeHtml(item.mode)}</span>
          </div>
          <div class="entry-desc">${escapeHtml(item.desc)}</div>
          <div class="entry-desc">示例：<code>${escapeHtml(item.example)}</code></div>
        `;

        const actions = document.createElement("div");
        actions.className = "entry-actions";
        const insertBtn = document.createElement("button");
        insertBtn.textContent = "插入按鍵";
        insertBtn.addEventListener("click", () => {
          state.keyBuffer = [];
          item.demoSequence.forEach((token) => pushKeyBuffer(token));
          setStatusMessage("已插入按鍵序列", "success");
        });
        const demoBtn = document.createElement("button");
        demoBtn.textContent = "示範";
        demoBtn.addEventListener("click", () => runDemo(item.demoSequence));
        actions.appendChild(insertBtn);
        actions.appendChild(demoBtn);
        card.appendChild(actions);
        listEl.appendChild(card);
      });
    };

    const runDemo = async (sequence) => {
      if (state.demoPlaying) return;
      state.demoPlaying = true;
      editor.focus();
      for (const key of sequence) {
        await new Promise((resolve) => setTimeout(resolve, 350));
        simulateKey(key);
      }
      state.demoPlaying = false;
    };

    const simulateKey = (token) => {
      if (token === "<Esc>") {
        pushKeyBuffer("<Esc>");
        setMode("NORMAL");
        return;
      }
      if (token === "<Enter>") {
        if (state.mode === "INSERT") {
          pushKeyBuffer("<Enter>");
          insertNewLine();
        } else if (state.mode === "COMMAND-LINE") {
          pushKeyBuffer("<Enter>");
          finishCommandLine();
        }
        return;
      }
      if (token === "<C-r>") {
        pushKeyBuffer("<C-r>");
        redo();
        return;
      }
      if (token === "<BS>") {
        pushKeyBuffer("<BS>");
        if (state.mode === "INSERT") backspace();
        if (state.mode === "COMMAND-LINE") {
          state.commandLine.value = state.commandLine.value.slice(0, -1);
          scheduleRender();
        }
        return;
      }
      if (token === ":" || token === "/") {
        pushKeyBuffer(token);
        startCommandLine(token);
        return;
      }

      if (state.mode === "INSERT") {
        pushKeyBuffer(token);
        insertText(token);
        return;
      }
      if (state.mode === "COMMAND-LINE") {
        pushKeyBuffer(token);
        state.commandLine.value += token;
        scheduleRender();
        return;
      }
      if (state.mode === "VISUAL") {
        pushKeyBuffer(token);
        handleVisualKey(token);
        return;
      }
      if (state.mode === "NORMAL") {
        pushKeyBuffer(token);
        handleNormalKey(token, {});
      }
    };

    const populateSamples = () => {
      samples.forEach((sample) => {
        const option = document.createElement("option");
        option.value = sample.id;
        option.textContent = `載入：${sample.name}`;
        sampleSelect.appendChild(option);
      });
    };

    const loadSample = (id) => {
      const sample = samples.find((item) => item.id === id);
      if (!sample) return;
      state.lines = sample.content.split("\n");
      state.cursor = { row: 0, col: 0 };
      state.filename = sample.filename;
      state.history = [];
      state.redo = [];
      state.search = { term: "", matches: [], index: -1 };
      state.selection = null;
      state.register = "";
      state.mode = "NORMAL";
      setStatusMessage(`已載入 ${sample.name}`, "success");
      scheduleRender();
    };

    sampleSelect.addEventListener("change", (event) => {
      if (event.target.value) {
        loadSample(event.target.value);
        event.target.value = "";
      }
    });

    resetBtn.addEventListener("click", () => {
      resetEditor();
      setStatusMessage("已重置", "warning");
    });

    searchInput.addEventListener("input", renderEncyclopedia);

    editor.addEventListener("keydown", handleKeydown);
    editor.addEventListener("click", () => editor.focus());

    const init = () => {
      populateSamples();
      renderTabs();
      renderEncyclopedia();
      loadSample("article");
      editor.focus();
    };

    init();
  </script>
</body>
</html>
